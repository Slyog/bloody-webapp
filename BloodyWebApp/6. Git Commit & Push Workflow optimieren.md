---
title: "Schritt 4 â€“ Git Commit & Push Workflow + Branching (Pro Setup)"
tags: [Git, GitHub, Branching, Workflow, Versionierung, DevOps]
date: 2025-10-18
aliases: [Git Workflow, Feature Branch, Dev Branch, Commit Push Setup]
---

# ğŸªœ Schritt 4: Git Commit & Push Workflow optimieren

ğŸ¯ **Ziel:**  
Ein professioneller Git-Workflow mit sauberen Branches, sinnvoller Versionierung und automatischer Doku Ã¼ber `README.md`.  
Damit arbeitest du wie ein echter Cloud-/DevOps-Engineer.

---

## âš™ï¸ 1ï¸âƒ£ Git-Initialisierung

Ã–ffne PowerShell im Projektordner:

```bash
cd C:\Users\slyse\Documents\Learning\arkwebapp\webapp
git init
```
Verbinde dein lokales Projekt mit GitHub:
```bash
git remote add origin https://github.com/<USER>/<REPO>.git
```
Checke, ob die Verbindung steht:
```
git remote -v
```
Wenn die Meldung kommt  
`remote origin already exists`,  
dann anpassen mit:
```
git remote set-url origin https://github.com/<USER>/<REPO>.git
```
## ğŸ“ 2ï¸âƒ£ .gitignore erstellen
Erstelle eine `.gitignore`, um unnÃ¶tige Dateien vom Upload auszuschlieÃŸen:

```bash
ni .gitignore -ItemType File
```
`ni` steht fÃ¼r **New-Item** in PowerShell â†’ erstellt eine neue Datei.  
`-ItemType File` legt fest, dass es sich um eine Datei (nicht Ordner) handelt.
Inhalt der Datei:

```lua
node_modules/
.env
.next/
.DS_Store
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
dist/
coverage/
```
## ğŸ§© 3ï¸âƒ£ Optional: README.md erstellen
```bash
ni README.md -ItemType File
```
Inhalt:
```markdown
# BloodyARK WebApp
Next.js + TailwindCSS v3 + MongoDB Starter-Setup.
```
## âš™ï¸ 4ï¸âƒ£ Git-Konfiguration (Windows-spezifisch)

```bash
git config --global core.autocrlf true
```
**ErklÃ¤rung:**

- `core.autocrlf` sorgt dafÃ¼r, dass Git automatisch ZeilenumbrÃ¼che (`\r\n` â†” `\n`) zwischen Windows und Linux korrigiert.
    
- Ohne das Setting bekommst du oft â€changed file endingsâ€œ-Fehler bei Commits zwischen Betriebssystemen.
## ğŸ§± 5ï¸âƒ£ Erstes Commit erstellen
```bash
git add .
git commit -m "init: Next.js + Tailwind v3 + MongoDB setup"
git branch -M main
```

â˜ï¸ 6ï¸âƒ£ Push auf GitHub
```bash
git push -u origin main
```
Falls Git meldet:
```css
! [rejected] main -> main (non-fast-forward)
```
â¡ï¸ Dann ist der Remote-Branch (z. B. durch README) schon belegt.  
LÃ¶sungen:

**Option A â€“ Dein Code ist die Hauptversion (einfach Ã¼berschreiben):**

```bash
git push --force origin main
```
**Option B â€“ Ã„nderungen erst einziehen:**
```bash
git pull origin main --rebase
git push origin main
```
## ğŸ§­ 7ï¸âƒ£ Branching-Strategie (Pro-Workflow)

Ein moderner Workflow nutzt 3 Ebenen:

| Branch      | Zweck                                                    |
| ----------- | -------------------------------------------------------- |
| `main`      | **stabiler Produktionscode** (z. B. fÃ¼r AWS Deployments) |
| `dev`       | Entwicklungs- / Testumgebung                             |
| `feature/*` | Einzelne Features, Experimente oder Bugfixes             |
### ğŸ”¹ Dev-Branch anlegen
```bash
git checkout -b dev
git push -u origin dev
```
Jetzt hast du:

- `main` â†’ stabil
    
- `dev` â†’ Entwicklungsbasis

### ğŸ”¹ Feature-Branch anlegen (z. B. Login-System)
```bash
git checkout dev
git checkout -b feature/login-system
```
Ã„nderungen machen, dann:
```bash
git add .
git commit -m "feat: add login system"
git push -u origin feature/login-system
```

## ğŸ”„ 8ï¸âƒ£ Merge-Prozess (Pull-Request-Style)
Wenn dein Feature funktioniert:

1. Ã–ffne GitHub â†’ geh zum Branch `feature/login-system`.
    
2. Erstelle einen **Pull Request (PR)** â†’ Ziel: `dev`.
    
3. Wenn getestet, merge `dev` â†’ `main`.
    

âœ… Ergebnis:

- `main` bleibt stabil
    
- `dev` dient als Testumgebung
    
- `feature/*`-Branches bleiben sauber getrennt
  
  ## ğŸ§  9ï¸âƒ£ NÃ¼tzliche Git-Befehle
- 
  ```json
  |Zweck|Befehl|
|---|---|
|Branches anzeigen|`git branch -a`|
|Zwischen Branches wechseln|`git checkout <branch>`|
|Lokalen Branch lÃ¶schen|`git branch -d feature/login-system`|
|Remote Branch lÃ¶schen|`git push origin --delete feature/login-system`|
|Letzten Commit Ã¤ndern|`git commit --amend`|
|Status prÃ¼fen|`git status`|
  ```
## Bonus: Automatische QualitÃ¤tssicherung (spÃ¤ter)

- Richte **GitHub Actions** oder **AWS CodePipeline** ein:  
    â†’ Jeder Push auf `main` lÃ¶st automatisches Deployment aus.  
    â†’ Jeder Push auf `dev` startet Tests oder Builds.
    

So arbeitest du wie ein Cloud Engineer mit echtem CI/CD-Workflow.

---

## âœ… Ergebnis nach Schritt 4

-  Git & GitHub sind verbunden
    
-  Lokale Commits und Pushs funktionieren
    
-  Branch-Struktur: `main`, `dev`, `feature/*`
    
-  `.gitignore` und `README.md` vorhanden
    
-  Core-Autocrlf aktiviert (keine Windows-Linux-Probleme)
    
-  Bereit fÃ¼r CI/CD (z. B. AWS, GitHub Actions)
