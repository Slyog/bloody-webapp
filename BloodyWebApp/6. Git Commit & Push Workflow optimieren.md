---
title: "Schritt 4 – Git Commit & Push Workflow + Branching (Pro Setup)"
tags: [Git, GitHub, Branching, Workflow, Versionierung, DevOps]
date: 2025-10-18
aliases: [Git Workflow, Feature Branch, Dev Branch, Commit Push Setup]
---

# 🪜 Schritt 4: Git Commit & Push Workflow optimieren

🎯 **Ziel:**  
Ein professioneller Git-Workflow mit sauberen Branches, sinnvoller Versionierung und automatischer Doku über `README.md`.  
Damit arbeitest du wie ein echter Cloud-/DevOps-Engineer.

---

## ⚙️ 1️⃣ Git-Initialisierung

Öffne PowerShell im Projektordner:

```bash
cd C:\Users\slyse\Documents\Learning\arkwebapp\webapp
git init
```
Verbinde dein lokales Projekt mit GitHub:
```bash
git remote add origin https://github.com/<USER>/<REPO>.git
```
Checke, ob die Verbindung steht:
```
git remote -v
```
Wenn die Meldung kommt  
`remote origin already exists`,  
dann anpassen mit:
```
git remote set-url origin https://github.com/<USER>/<REPO>.git
```
## 📁 2️⃣ .gitignore erstellen
Erstelle eine `.gitignore`, um unnötige Dateien vom Upload auszuschließen:

```bash
ni .gitignore -ItemType File
```
`ni` steht für **New-Item** in PowerShell → erstellt eine neue Datei.  
`-ItemType File` legt fest, dass es sich um eine Datei (nicht Ordner) handelt.
Inhalt der Datei:

```lua
node_modules/
.env
.next/
.DS_Store
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
dist/
coverage/
```
## 🧩 3️⃣ Optional: README.md erstellen
```bash
ni README.md -ItemType File
```
Inhalt:
```markdown
# BloodyARK WebApp
Next.js + TailwindCSS v3 + MongoDB Starter-Setup.
```
## ⚙️ 4️⃣ Git-Konfiguration (Windows-spezifisch)

```bash
git config --global core.autocrlf true
```
**Erklärung:**

- `core.autocrlf` sorgt dafür, dass Git automatisch Zeilenumbrüche (`\r\n` ↔ `\n`) zwischen Windows und Linux korrigiert.
    
- Ohne das Setting bekommst du oft „changed file endings“-Fehler bei Commits zwischen Betriebssystemen.
## 🧱 5️⃣ Erstes Commit erstellen
```bash
git add .
git commit -m "init: Next.js + Tailwind v3 + MongoDB setup"
git branch -M main
```

☁️ 6️⃣ Push auf GitHub
```bash
git push -u origin main
```
Falls Git meldet:
```css
! [rejected] main -> main (non-fast-forward)
```
➡️ Dann ist der Remote-Branch (z. B. durch README) schon belegt.  
Lösungen:

**Option A – Dein Code ist die Hauptversion (einfach überschreiben):**

```bash
git push --force origin main
```
**Option B – Änderungen erst einziehen:**
```bash
git pull origin main --rebase
git push origin main
```
## 🧭 7️⃣ Branching-Strategie (Pro-Workflow)

Ein moderner Workflow nutzt 3 Ebenen:

| Branch      | Zweck                                                    |
| ----------- | -------------------------------------------------------- |
| `main`      | **stabiler Produktionscode** (z. B. für AWS Deployments) |
| `dev`       | Entwicklungs- / Testumgebung                             |
| `feature/*` | Einzelne Features, Experimente oder Bugfixes             |
### 🔹 Dev-Branch anlegen
```bash
git checkout -b dev
git push -u origin dev
```
Jetzt hast du:

- `main` → stabil
    
- `dev` → Entwicklungsbasis

### 🔹 Feature-Branch anlegen (z. B. Login-System)
```bash
git checkout dev
git checkout -b feature/login-system
```
Änderungen machen, dann:
```bash
git add .
git commit -m "feat: add login system"
git push -u origin feature/login-system
```

## 🔄 8️⃣ Merge-Prozess (Pull-Request-Style)
Wenn dein Feature funktioniert:

1. Öffne GitHub → geh zum Branch `feature/login-system`.
    
2. Erstelle einen **Pull Request (PR)** → Ziel: `dev`.
    
3. Wenn getestet, merge `dev` → `main`.
    

✅ Ergebnis:

- `main` bleibt stabil
    
- `dev` dient als Testumgebung
    
- `feature/*`-Branches bleiben sauber getrennt
  
  ## 🧠 9️⃣ Nützliche Git-Befehle
- 
  ```json
  |Zweck|Befehl|
|---|---|
|Branches anzeigen|`git branch -a`|
|Zwischen Branches wechseln|`git checkout <branch>`|
|Lokalen Branch löschen|`git branch -d feature/login-system`|
|Remote Branch löschen|`git push origin --delete feature/login-system`|
|Letzten Commit ändern|`git commit --amend`|
|Status prüfen|`git status`|
  ```
## Bonus: Automatische Qualitätssicherung (später)

- Richte **GitHub Actions** oder **AWS CodePipeline** ein:  
    → Jeder Push auf `main` löst automatisches Deployment aus.  
    → Jeder Push auf `dev` startet Tests oder Builds.
    

So arbeitest du wie ein Cloud Engineer mit echtem CI/CD-Workflow.

---

## ✅ Ergebnis nach Schritt 4

-  Git & GitHub sind verbunden
    
-  Lokale Commits und Pushs funktionieren
    
-  Branch-Struktur: `main`, `dev`, `feature/*`
    
-  `.gitignore` und `README.md` vorhanden
    
-  Core-Autocrlf aktiviert (keine Windows-Linux-Probleme)
    
-  Bereit für CI/CD (z. B. AWS, GitHub Actions)
